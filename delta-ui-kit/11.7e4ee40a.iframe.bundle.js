"use strict";(self.webpackChunkdelta_ui_kit=self.webpackChunkdelta_ui_kit||[]).push([[11],{"../../node_modules/react-leaflet/lib/index.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{AttributionControl:()=>AttributionControl,Circle:()=>Circle,CircleMarker:()=>CircleMarker,FeatureGroup:()=>FeatureGroup,GeoJSON:()=>GeoJSON,ImageOverlay:()=>ImageOverlay,LayerGroup:()=>LayerGroup,LayersControl:()=>LayersControl,MapContainer:()=>MapContainer,Marker:()=>Marker,Pane:()=>Pane,Polygon:()=>Polygon,Polyline:()=>Polyline,Popup:()=>Popup,Rectangle:()=>Rectangle,SVGOverlay:()=>SVGOverlay,ScaleControl:()=>ScaleControl,TileLayer:()=>TileLayer,Tooltip:()=>Tooltip,VideoOverlay:()=>VideoOverlay,WMSTileLayer:()=>WMSTileLayer,ZoomControl:()=>ZoomControl,useMap:()=>useMap,useMapEvent:()=>useMapEvent,useMapEvents:()=>useMapEvents});var react=__webpack_require__("../../node_modules/react/index.js");function extendContext(source,extra){return Object.freeze({...source,...extra})}const LeafletContext=(0,react.createContext)(null),LeafletProvider=LeafletContext.Provider;function useLeafletContext(){const context=(0,react.useContext)(LeafletContext);if(null==context)throw new Error("No context provided: useLeafletContext() can only be used in a descendant of <MapContainer>");return context}function useMap(){return useLeafletContext().map}function useMapEvent(type,handler){const map=useMap();return(0,react.useEffect)((function addMapEventHandler(){return map.on(type,handler),function removeMapEventHandler(){map.off(type,handler)}}),[map,type,handler]),map}function useMapEvents(handlers){const map=useMap();return(0,react.useEffect)((function addMapEventHandlers(){return map.on(handlers),function removeMapEventHandlers(){map.off(handlers)}}),[map,handlers]),map}var react_dom=__webpack_require__("../../node_modules/react-dom/index.js");function createContainerComponent(useElement){function ContainerComponent(props,forwardedRef){const{instance,context}=useElement(props).current;return(0,react.useImperativeHandle)(forwardedRef,(()=>instance)),null==props.children?null:react.createElement(LeafletProvider,{value:context},props.children)}return(0,react.forwardRef)(ContainerComponent)}function createLeafComponent(useElement){function LeafComponent(props,forwardedRef){const{instance}=useElement(props).current;return(0,react.useImperativeHandle)(forwardedRef,(()=>instance)),null}return(0,react.forwardRef)(LeafComponent)}function createControlHook(useElement){return function useLeafletControl(props){const context=useLeafletContext(),elementRef=useElement(props,context),{instance}=elementRef.current,positionRef=(0,react.useRef)(props.position),{position}=props;return(0,react.useEffect)((function addControl(){return instance.addTo(context.map),function removeControl(){instance.remove()}}),[context.map,instance]),(0,react.useEffect)((function updateControl(){null!=position&&position!==positionRef.current&&(instance.setPosition(position),positionRef.current=position)}),[instance,position]),elementRef}}function createElementObject(instance,context,container){return Object.freeze({instance,context,container})}function createElementHook(createElement,updateElement){return null==updateElement?function useImmutableLeafletElement(props,context){const elementRef=(0,react.useRef)();return elementRef.current||(elementRef.current=createElement(props,context)),elementRef}:function useMutableLeafletElement(props,context){const elementRef=(0,react.useRef)();elementRef.current||(elementRef.current=createElement(props,context));const propsRef=(0,react.useRef)(props),{instance}=elementRef.current;return(0,react.useEffect)((function updateElementProps(){propsRef.current!==props&&(updateElement(instance,props,propsRef.current),propsRef.current=props)}),[instance,props,context]),elementRef}}function useAttribution(map,attribution){const attributionRef=(0,react.useRef)(attribution);(0,react.useEffect)((function updateAttribution(){attribution!==attributionRef.current&&null!=map.attributionControl&&(null!=attributionRef.current&&map.attributionControl.removeAttribution(attributionRef.current),null!=attribution&&map.attributionControl.addAttribution(attribution)),attributionRef.current=attribution}),[map,attribution])}function useEventHandlers(element,eventHandlers){const eventHandlersRef=(0,react.useRef)();(0,react.useEffect)((function addEventHandlers(){return null!=eventHandlers&&element.instance.on(eventHandlers),eventHandlersRef.current=eventHandlers,function removeEventHandlers(){null!=eventHandlersRef.current&&element.instance.off(eventHandlersRef.current),eventHandlersRef.current=null}}),[element,eventHandlers])}function withPane(props,context){const pane=props.pane??context.pane;return pane?{...props,pane}:props}function useLayerLifecycle(element,context){(0,react.useEffect)((function addLayer(){return(context.layerContainer??context.map).addLayer(element.instance),function removeLayer(){context.layerContainer?.removeLayer(element.instance),context.map.removeLayer(element.instance)}}),[context,element])}function createLayerHook(useElement){return function useLayer(props){const context=useLeafletContext(),elementRef=useElement(withPane(props,context),context);return useAttribution(context.map,props.attribution),useEventHandlers(elementRef.current,props.eventHandlers),useLayerLifecycle(elementRef.current,context),elementRef}}function createPathHook(useElement){return function usePath(props){const context=useLeafletContext(),elementRef=useElement(withPane(props,context),context);return useEventHandlers(elementRef.current,props.eventHandlers),useLayerLifecycle(elementRef.current,context),function usePathOptions(element,props){const optionsRef=(0,react.useRef)();(0,react.useEffect)((function updatePathOptions(){if(props.pathOptions!==optionsRef.current){const options=props.pathOptions??{};element.instance.setStyle(options),optionsRef.current=options}}),[element,props])}(elementRef.current,props),elementRef}}function createControlComponent(createInstance){return createLeafComponent(createControlHook(createElementHook((function createElement(props,context){return createElementObject(createInstance(props),context)}))))}function createLayerComponent(createElement,updateElement){return createContainerComponent(createLayerHook(createElementHook(createElement,updateElement)))}function createOverlayComponent(createElement,useLifecycle){const useOverlay=function createDivOverlayHook(useElement,useLifecycle){return function useDivOverlay(props,setOpen){const context=useLeafletContext(),elementRef=useElement(withPane(props,context),context);return useAttribution(context.map,props.attribution),useEventHandlers(elementRef.current,props.eventHandlers),useLifecycle(elementRef.current,context,props,setOpen),elementRef}}(createElementHook(createElement),useLifecycle);return function createDivOverlayComponent(useElement){function OverlayComponent(props,forwardedRef){const[isOpen,setOpen]=(0,react.useState)(!1),{instance}=useElement(props,setOpen).current;(0,react.useImperativeHandle)(forwardedRef,(()=>instance)),(0,react.useEffect)((function updateOverlay(){isOpen&&instance.update()}),[instance,isOpen,props.children]);const contentNode=instance._contentNode;return contentNode?(0,react_dom.createPortal)(props.children,contentNode):null}return(0,react.forwardRef)(OverlayComponent)}(useOverlay)}function createPathComponent(createElement,updateElement){return createContainerComponent(createPathHook(createElementHook(createElement,updateElement)))}function createTileLayerComponent(createElement,updateElement){return createLeafComponent(createLayerHook(createElementHook(createElement,updateElement)))}var leaflet_src=__webpack_require__("../../node_modules/leaflet/dist/leaflet-src.js");const AttributionControl=createControlComponent((function createAttributionControl(props){return new leaflet_src.Control.Attribution(props)}));function updateCircle(layer,props,prevProps){props.center!==prevProps.center&&layer.setLatLng(props.center),null!=props.radius&&props.radius!==prevProps.radius&&layer.setRadius(props.radius)}const Circle=createPathComponent((function createCircle({center,children:_c,...options},ctx){const circle=new leaflet_src.Circle(center,options);return createElementObject(circle,extendContext(ctx,{overlayContainer:circle}))}),updateCircle),CircleMarker=createPathComponent((function createCircleMarker({center,children:_c,...options},ctx){const marker=new leaflet_src.CircleMarker(center,options);return createElementObject(marker,extendContext(ctx,{overlayContainer:marker}))}),updateCircle),FeatureGroup=createPathComponent((function createFeatureGroup({children:_c,...options},ctx){const group=new leaflet_src.FeatureGroup([],options);return createElementObject(group,extendContext(ctx,{layerContainer:group,overlayContainer:group}))})),GeoJSON=createPathComponent((function createGeoJSON({data,...options},ctx){const geoJSON=new leaflet_src.GeoJSON(data,options);return createElementObject(geoJSON,extendContext(ctx,{overlayContainer:geoJSON}))}),(function updateGeoJSON(layer,props,prevProps){props.style!==prevProps.style&&(null==props.style?layer.resetStyle():layer.setStyle(props.style))}));function updateMediaOverlay(overlay,props,prevProps){props.bounds instanceof leaflet_src.LatLngBounds&&props.bounds!==prevProps.bounds&&overlay.setBounds(props.bounds),null!=props.opacity&&props.opacity!==prevProps.opacity&&overlay.setOpacity(props.opacity),null!=props.zIndex&&props.zIndex!==prevProps.zIndex&&overlay.setZIndex(props.zIndex)}const ImageOverlay=createLayerComponent((function createImageOveraly({bounds,url,...options},ctx){const overlay=new leaflet_src.ImageOverlay(url,bounds,options);return createElementObject(overlay,extendContext(ctx,{overlayContainer:overlay}))}),(function updateImageOverlay(overlay,props,prevProps){if(updateMediaOverlay(overlay,props,prevProps),props.bounds!=props.bounds){const bounds=props.bounds instanceof leaflet_src.LatLngBounds?props.bounds:new leaflet_src.LatLngBounds(props.bounds);overlay.setBounds(bounds)}props.url!==prevProps.url&&overlay.setUrl(props.url)})),LayerGroup=createLayerComponent((function createLayerGroup({children:_c,...options},ctx){const group=new leaflet_src.LayerGroup([],options);return createElementObject(group,extendContext(ctx,{layerContainer:group}))})),LayersControl=createContainerComponent(createControlHook(createElementHook((function createLayersControl({children:_c,...options},ctx){const control=new leaflet_src.Control.Layers(void 0,void 0,options);return createElementObject(control,extendContext(ctx,{layersControl:control}))}),(function updateLayersControl(control,props,prevProps){props.collapsed!==prevProps.collapsed&&(!0===props.collapsed?control.collapse():control.expand())}))));function createControlledLayer(addLayerToControl){return function ControlledLayer(props){const parentContext=useLeafletContext(),propsRef=(0,react.useRef)(props),[layer,setLayer]=(0,react.useState)(null),{layersControl,map}=parentContext,addLayer=(0,react.useCallback)((layerToAdd=>{null!=layersControl&&(propsRef.current.checked&&map.addLayer(layerToAdd),addLayerToControl(layersControl,layerToAdd,propsRef.current.name),setLayer(layerToAdd))}),[layersControl,map]),removeLayer=(0,react.useCallback)((layerToRemove=>{layersControl?.removeLayer(layerToRemove),setLayer(null)}),[layersControl]),context=(0,react.useMemo)((()=>extendContext(parentContext,{layerContainer:{addLayer,removeLayer}})),[parentContext,addLayer,removeLayer]);return(0,react.useEffect)((()=>{null!==layer&&propsRef.current!==props&&(!0!==props.checked||null!=propsRef.current.checked&&!1!==propsRef.current.checked?!0!==propsRef.current.checked||null!=props.checked&&!1!==props.checked||map.removeLayer(layer):map.addLayer(layer),propsRef.current=props)})),props.children?react.createElement(LeafletProvider,{value:context},props.children):null}}function _extends(){return _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},_extends.apply(this,arguments)}function MapContainerComponent({bounds,boundsOptions,center,children,className,id,placeholder,style,whenReady,zoom,...options},forwardedRef){const[props]=(0,react.useState)({className,id,style}),[context,setContext]=(0,react.useState)(null);(0,react.useImperativeHandle)(forwardedRef,(()=>context?.map??null),[context]);const mapRef=(0,react.useCallback)((node=>{if(null!==node&&null===context){const map=new leaflet_src.Map(node,options);null!=center&&null!=zoom?map.setView(center,zoom):null!=bounds&&map.fitBounds(bounds,boundsOptions),null!=whenReady&&map.whenReady(whenReady),setContext(function createLeafletContext(map){return Object.freeze({__version:1,map})}(map))}}),[]);(0,react.useEffect)((()=>()=>{context?.map.remove()}),[context]);const contents=context?react.createElement(LeafletProvider,{value:context},children):placeholder??null;return react.createElement("div",_extends({},props,{ref:mapRef}),contents)}LayersControl.BaseLayer=createControlledLayer((function addBaseLayer(layersControl,layer,name){layersControl.addBaseLayer(layer,name)})),LayersControl.Overlay=createControlledLayer((function addOverlay(layersControl,layer,name){layersControl.addOverlay(layer,name)}));const MapContainer=(0,react.forwardRef)(MapContainerComponent),Marker=createLayerComponent((function createMarker({position,...options},ctx){const marker=new leaflet_src.Marker(position,options);return createElementObject(marker,extendContext(ctx,{overlayContainer:marker}))}),(function updateMarker(marker,props,prevProps){props.position!==prevProps.position&&marker.setLatLng(props.position),null!=props.icon&&props.icon!==prevProps.icon&&marker.setIcon(props.icon),null!=props.zIndexOffset&&props.zIndexOffset!==prevProps.zIndexOffset&&marker.setZIndexOffset(props.zIndexOffset),null!=props.opacity&&props.opacity!==prevProps.opacity&&marker.setOpacity(props.opacity),null!=marker.dragging&&props.draggable!==prevProps.draggable&&(!0===props.draggable?marker.dragging.enable():marker.dragging.disable())}));function splitClassName(className){return className.split(" ").filter(Boolean)}function addClassName(element,className){splitClassName(className).forEach((cls=>{leaflet_src.DomUtil.addClass(element,cls)}))}const DEFAULT_PANES=["mapPane","markerPane","overlayPane","popupPane","shadowPane","tilePane","tooltipPane"];function omitPane(obj,pane){const{[pane]:_p,...others}=obj;return others}function PaneComponent(props,forwardedRef){const[paneName]=(0,react.useState)(props.name),[paneElement,setPaneElement]=(0,react.useState)(null);(0,react.useImperativeHandle)(forwardedRef,(()=>paneElement),[paneElement]);const context=useLeafletContext(),newContext=(0,react.useMemo)((()=>({...context,pane:paneName})),[context]);return(0,react.useEffect)((()=>(setPaneElement(function createPane(name,props,context){if(-1!==DEFAULT_PANES.indexOf(name))throw new Error(`You must use a unique name for a pane that is not a default Leaflet pane: ${name}`);if(null!=context.map.getPane(name))throw new Error(`A pane with this name already exists: ${name}`);const parentPaneName=props.pane??context.pane,parentPane=parentPaneName?context.map.getPane(parentPaneName):void 0,element=context.map.createPane(name,parentPane);return null!=props.className&&addClassName(element,props.className),null!=props.style&&Object.keys(props.style).forEach((key=>{element.style[key]=props.style[key]})),element}(paneName,props,context)),function removeCreatedPane(){context.map.getPane(paneName)?.remove?.(),null!=context.map._panes&&(context.map._panes=omitPane(context.map._panes,paneName),context.map._paneRenderers=omitPane(context.map._paneRenderers,paneName))})),[]),null!=props.children&&null!=paneElement?(0,react_dom.createPortal)(react.createElement(LeafletProvider,{value:newContext},props.children),paneElement):null}const Pane=(0,react.forwardRef)(PaneComponent),Polygon=createPathComponent((function createPolygon({positions,...options},ctx){const polygon=new leaflet_src.Polygon(positions,options);return createElementObject(polygon,extendContext(ctx,{overlayContainer:polygon}))}),(function updatePolygon(layer,props,prevProps){props.positions!==prevProps.positions&&layer.setLatLngs(props.positions)})),Polyline=createPathComponent((function createPolyline({positions,...options},ctx){const polyline=new leaflet_src.Polyline(positions,options);return createElementObject(polyline,extendContext(ctx,{overlayContainer:polyline}))}),(function updatePolyline(layer,props,prevProps){props.positions!==prevProps.positions&&layer.setLatLngs(props.positions)})),Popup=createOverlayComponent((function createPopup(props,context){return createElementObject(new leaflet_src.Popup(props,context.overlayContainer),context)}),(function usePopupLifecycle(element,context,{position},setOpen){(0,react.useEffect)((function addPopup(){const{instance}=element;function onPopupOpen(event){event.popup===instance&&(instance.update(),setOpen(!0))}function onPopupClose(event){event.popup===instance&&setOpen(!1)}return context.map.on({popupopen:onPopupOpen,popupclose:onPopupClose}),null==context.overlayContainer?(null!=position&&instance.setLatLng(position),instance.openOn(context.map)):context.overlayContainer.bindPopup(instance),function removePopup(){context.map.off({popupopen:onPopupOpen,popupclose:onPopupClose}),context.overlayContainer?.unbindPopup(),context.map.removeLayer(instance)}}),[element,context,setOpen,position])})),Rectangle=createPathComponent((function createRectangle({bounds,...options},ctx){const rectangle=new leaflet_src.Rectangle(bounds,options);return createElementObject(rectangle,extendContext(ctx,{overlayContainer:rectangle}))}),(function updateRectangle(layer,props,prevProps){props.bounds!==prevProps.bounds&&layer.setBounds(props.bounds)})),ScaleControl=createControlComponent((function createScaleControl(props){return new leaflet_src.Control.Scale(props)})),useSVGOverlay=createLayerHook(createElementHook((function createSVGOverlay(props,context){const{attributes,bounds,...options}=props,container=document.createElementNS("http://www.w3.org/2000/svg","svg");container.setAttribute("xmlns","http://www.w3.org/2000/svg"),null!=attributes&&Object.keys(attributes).forEach((name=>{container.setAttribute(name,attributes[name])}));return createElementObject(new leaflet_src.SVGOverlay(container,bounds,options),context,container)}),updateMediaOverlay));function SVGOverlayComponent({children,...options},forwardedRef){const{instance,container}=useSVGOverlay(options).current;return(0,react.useImperativeHandle)(forwardedRef,(()=>instance)),null==container||null==children?null:(0,react_dom.createPortal)(children,container)}const SVGOverlay=(0,react.forwardRef)(SVGOverlayComponent);function updateGridLayer(layer,props,prevProps){const{opacity,zIndex}=props;null!=opacity&&opacity!==prevProps.opacity&&layer.setOpacity(opacity),null!=zIndex&&zIndex!==prevProps.zIndex&&layer.setZIndex(zIndex)}const TileLayer=createTileLayerComponent((function createTileLayer({url,...options},context){return createElementObject(new leaflet_src.TileLayer(url,withPane(options,context)),context)}),updateGridLayer),Tooltip=createOverlayComponent((function createTooltip(props,context){return createElementObject(new leaflet_src.Tooltip(props,context.overlayContainer),context)}),(function useTooltipLifecycle(element,context,{position},setOpen){(0,react.useEffect)((function addTooltip(){const container=context.overlayContainer;if(null==container)return;const{instance}=element,onTooltipOpen=event=>{event.tooltip===instance&&(null!=position&&instance.setLatLng(position),instance.update(),setOpen(!0))},onTooltipClose=event=>{event.tooltip===instance&&setOpen(!1)};return container.on({tooltipopen:onTooltipOpen,tooltipclose:onTooltipClose}),container.bindTooltip(instance),function removeTooltip(){container.off({tooltipopen:onTooltipOpen,tooltipclose:onTooltipClose}),null!=container._map&&container.unbindTooltip()}}),[element,context,setOpen,position])})),VideoOverlay=createLayerComponent((function createVideoOverlay({bounds,url,...options},ctx){const overlay=new leaflet_src.VideoOverlay(url,bounds,options);return!0===options.play&&overlay.getElement()?.play(),createElementObject(overlay,extendContext(ctx,{overlayContainer:overlay}))}),(function updateVideoOverlay(overlay,props,prevProps){updateMediaOverlay(overlay,props,prevProps),"string"==typeof props.url&&props.url!==prevProps.url&&overlay.setUrl(props.url);const video=overlay.getElement();null!=video&&(!0!==props.play||prevProps.play?props.play||!0!==prevProps.play||video.pause():video.play())})),WMSTileLayer=createTileLayerComponent((function createWMSTileLayer({eventHandlers:_eh,params={},url,...options},context){return createElementObject(new leaflet_src.TileLayer.WMS(url,{...params,...withPane(options,context)}),context)}),(function updateWMSTileLayer(layer,props,prevProps){updateGridLayer(layer,props,prevProps),null!=props.params&&props.params!==prevProps.params&&layer.setParams(props.params)})),ZoomControl=createControlComponent((function createZoomControl(props){return new leaflet_src.Control.Zoom(props)}))}}]);